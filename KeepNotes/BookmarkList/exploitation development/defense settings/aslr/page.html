<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>ASLR</title>
</head><body>ASLR is Adress Space Layout Randomization. ASLR randomizes the base addresses of loaded applications and DLLs. This means that you CANNOT just jump to shellcode addresses because the address space will be randomized on execution. There is a possibility to bruteforce (run the program enough times until you hit the address) or you have to calculate the address on the fly somehow.<br/>
<br/>
Linux kernel 2.6.8 by default doesn't have ASRL (ASLR got added into the Linux kernel by default from 2.6.12 onwards), therefore the attacker doesn't have to worry about ASLR on older kernels (typically)<br/>
<br/>
In linux, ASLR is typically set in proc/sys/kernel/randomize_va_space with value of 1. You can turn it off if you have permissions:<br/>
# echo 0 &gt; /proc/sys/kernel/randomize_va_space<br/>
<br/>
You can set /proc/sys/kernel/randomize_va_space with a value of 2 to force it on for everything. <br/>
# echo 2 &gt; /proc/sys/kernel/randomize_va_space<br/>
<br/>
value meanings:<br/>
0: ASLR disabled<br/>
1: ASLR (stack, virtual dynamic shared object page, and shared memory regions)<br/>
2: ASLR (1 + shared data segments as well)<br/>
<br/>
You can also use ldd to help identify if ASLR is active<br/>
# ldd &lt;binary&gt; | grep libc<br/>
If the address that is returned changes with each invocation of ldd, then ASLR is enabeld</body></html>